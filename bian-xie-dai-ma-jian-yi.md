1. 在序列化类中不使用构造函数为final变量赋值

1. 手动替换class文件不可取（静态变量修改后需编译后才会修改）

2. 用偶数判断不用奇数判断

3. 重要的数字入参需要判断边界

4. BigDecimal 使用String构造参数为最优选择

5. 包装类型使用euqals方法比较是否是相等 或者用转化为基本类型比较（大小会根据相关的方法比较）

包装类都是采用valueOf\(\)方法转换的 其中-128-127都是从缓存从取的不会再堆上产生新的对象。

\(java9 废除包装类相关基本类型的构造器，改用静态方法ValueOf替代\)

1. 一般情况最好不要重写父类静态方法\(当然如果你能区分表明类型和实际类型,你可以试试\)。Idea IDE中你需要手动重写

@Override 注解也无法作用在静态方法上的。

1. 不使用实例访问静态方法，这是代码的坏味道。还是用类名访问吧。

2. 构造函数尽量简单。这里的简单的意思是不要在其中做复杂的初始化代码。（调用其他方法或者其他类的构造器、为final变量赋值等）

在面向对象语言中，除非非常了解类的执行过程，否则还是尝试简洁明了的方式构建代码结构。

1. 静态代码块会再构造函数内首先执行（如果构造函数中有this和super这两个关键字，

静态代码块是不会插入到这个构造函数前执行的，确保每个构造函数只执行一次静态代码块）。作用一般为实例化变量和实例化环境。

1. 内部类实现多继承

2. 避免浅拷贝

3. 工具类最好使用final来避免继承 构造器私有化

4. 尽可能的使用局部变量

5. 中文排序Collator类

6. 基本类型优先使用

7. 集合初始化的时候非常有必要声明容量

8. 最值计算时使用集合最简单，使用数组性能最优

9. Arrays 只使用只读列表操作

10. 不同的集合采用不同的遍历方法。随机访问 无序存储的使用fori 有序的使用foreach 或者迭代器

11. 列表相等\(equals\) 只关心数据元素

12. subList方法生成子列表时，原始列表保持只读状态

13. 利用好集合replaceAll 等方法能优雅实现集合的去重（注意集合的浅拷贝）

14. switch case 判断值是否为空

15. 枚举使用的valueOf时候前 校验时候存在该种枚举的值

16. 枚举最好使用工厂方式

17. 反射效率低是个真命题，但因此而不使用它就是个假命题

18. final块中不要出现return 语句

19. 构造函数里不要抛出异常

20. 异常只为异常服务，不能用来作为正常的主逻辑（除非真的无法避免）

21. try catch 虽然性能比较慢 但是不能做为拒绝异常的理由

22. 线程的优先级推荐使用MIN\_PRIORITY（1） NORM\_PRIORITY（5） MAX\_PRIORITY（10） 级别 不建议使用其他的7个数字

23. Optional可以避免空指针异常和减少if else逻辑 不可直接调用ifParent\(\)



