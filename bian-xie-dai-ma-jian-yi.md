* 在序列化类中不使用构造函数为final变量赋值
* 手动替换class文件不可取（静态变量修改后需编译后才会修改）
* 用偶数判断不用奇数判断
* 重要的数字入参需要判断边界
* BigDecimal 使用String构造参数为最优选择
* 包装类型使用euqals方法比较是否是相等 或者用转化为基本类型比较（大小会根据相关的方法比较）
* 包装类都是采用valueOf\(\)方法转换的 其中-128-127都是从缓存从取的不会再堆上产生新的对象。
* \(java9 废除包装类相关基本类型的构造器，改用静态方法ValueOf替代\)
* 一般情况最好不要重写父类静态方法\(当然如果你能区分表明类型和实际类型,你可以试试\)。Idea IDE中你需要手动重写
* @Override 注解也无法作用在静态方法上的。
* 不使用实例访问静态方法，这是代码的坏味道。还是用类名访问吧。
* 构造函数尽量简单。这里的简单的意思是不要在其中做复杂的初始化代码。（调用其他方法或者其他类的构造器、为final变量赋值等）
* 在面向对象语言中，除非非常了解类的执行过程，否则还是尝试简洁明了的方式构建代码结构。
* 静态代码块会再构造函数内首先执行（如果构造函数中有this和super这两个关键字，
* 静态代码块是不会插入到这个构造函数前执行的，确保每个构造函数只执行一次静态代码块）。作用一般为实例化变量和实例化环境。
* 内部类实现多继承
* 避免浅拷贝
* 工具类最好使用final来避免继承 构造器私有化
* 尽可能的使用局部变量
* 中文排序Collator类
* 基本类型优先使用
* 集合初始化的时候非常有必要声明容量
* 最值计算时使用集合最简单，使用数组性能最优
* Arrays 只使用只读列表操作
* 不同的集合采用不同的遍历方法。随机访问 无序存储的使用fori 有序的使用foreach 或者迭代器
* 列表相等\(equals\) 只关心数据元素
* subList方法生成子列表时，原始列表保持只读状态
* 利用好集合replaceAll 等方法能优雅实现集合的去重（注意集合的浅拷贝）
* switch case 判断值是否为空
* 枚举使用的valueOf时候前 校验时候存在该种枚举的值
* 枚举最好使用工厂方式
* 反射效率低是个真命题，但因此而不使用它就是个假命题
* final块中不要出现return 语句
* 构造函数里不要抛出异常
* 异常只为异常服务，不能用来作为正常的主逻辑（除非真的无法避免）
* try catch 虽然性能比较慢 但是不能做为拒绝异常的理由
* 线程的优先级推荐使用MIN\_PRIORITY（1） NORM\_PRIORITY（5） MAX\_PRIORITY（10） 级别 不建议使用其他的7个数字
* Optional可以避免空指针异常和减少if else逻辑 不可直接调用ifParent\(\)





